**A:  Circle in a Rectangle / 長方形の中の円** [[問題](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP1_2_D&lang=jp)]  
長方形の長さ(w)，高さ(h)，円の中心座標(x,y)と半径(r)が与えられ，円のすべての部分が長方形の内部に存在するか否かを判別する問題．  
円は真円なので，中心座標が 左下(0+r, 0+r) から 右上(w-r, h-r) までの間に存在すればOK．  
→ 条件            : ( x > 0 + r && y > 0 + r ) && ( x < w - r && y < h - r )  
NOTを取ると : x < r || y < r || x > w - r || y > h - r   → このとき，”No"を出力．


**B:	Distance II / ミンコフスキー距離** [[問題](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP1_10_D&lang=jp)]  
x = {x_1, x_2, ... x_n} , y = {y_1, y_2, ... y_n} からなる2つのn次元ベクトルが与えられ，  
D_xy = ( \sum_i=1^n |x_i - y_i|^p )^1/p のミンコフスキー距離を，p=1,2,3,∞の場合について求める問題．  

D_xyの式を見ると，|x_i - y_i|の部分は共通 → 先に計算しておく．(xyとおく)  
p=1のとき：D = xyの合計  
p=2のとき：D = xyの二乗平均 =〉各xyを二乗して合計して平方根をとる．(pow -> sum -> sqrt)  
p=3のとき：D = (Σ|x_i - y_i|^3)^1/3 となり，1/3乗するか立方根をとる．  
→3乗はpow関数なり3回掛けるなりする．  
→立方根はライブラリを呼ぶ(cbrt関数 (C言語 立方根 [検索]) )か，何らかの方法で近似する → ex.)ニュートン法により近似  
p=∞のとき：xyを合計せずに，その中から最大値を見つける．だけ．（問題文より）  


**C:  Income Inequality / 所得格差** [[問題](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1624&lang=jp)]  
ｎ人，というデータ数を表す入力と，a_1, a_2, ... a_n からなるｎ人の所得を表す数列が入力として与えられ，ｎ人の所得の平均以下の所得の人数を答える問題．  
nが入力され，次の行にa_nが入力されるが，”0"が入力されない限り，繰り返し入力される点に注意．  
→ while文などを用いてn==0の条件判定によりループを終了する．  

単純に各データセットについて平均をとり(O(n))，データセットに対して平均以下である場合を条件判定し，カウントする(O(n))．  
n<10000（10^4）であり，時間制限も8sなので，十分間に合う？．


**D:	Taro's Shopping / 太郎君の買い物** [[問題](judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1616&lang=jp)]  
品物の数n, 使って良い金額m ，各品物の価格 a_i が与えられ，その中から”金額mを超えない限りで”価格が最大になる2個の品物を選び，その価格を答える問題．  
選ぶ品物が2個だけのナップサック問題（KP）と考えることもできる．  
（厳密には重さの制約ではなく，価値の制約なのでKPとは捉えられない?）  

制約条件：金額mを超えないこと．  
**（全探索/深さ優先探索(DFS)）**  
考え方：１．最大値を０としておく．  
  ２．2個の品物を選び，合計金額を算出する．  
  ３．金額ｍより小さく，今まで選んだものの最大値より高ければ，最大値を更新．  
  ４．↑の操作を品物A+B, A+C, A+D , ... B+A, B+C, ... とすべての組み合わせに対して計算する．  
（ただし，入力と探索/出力を分ける場合，n,a の配列がデータセットの最大数だけの配列を確保しなければならないため，工夫が必要．また，選べる品物の数や総数が増えると，探索時間が指数関数的に増加する）  
（動的配列を用いないC言語の場合，50000のサイズの配列を定義するとStackOverFlowを起こす．→mallocなり文字列として格納するなりetc...））  
**（分枝限定法/バックトラック）**  
（一般的なKPでは）品物を選んでいく際，制約条件を超えた時点でそれ以降の組み合わせを計算しないことで，計算量を減らす手法．  
ただし，今回の場合，品物がせいぜい２個までしか選べないので，無意味？  
**（メモ化再帰/動的計画法(DP)）**  
全探索の「４．」にて，例えばA+BとB+Aの結果は同じ．  
A+Bの結果を保存しておき，B+Aのときはその結果を参照することで，計算を省く．  
or A+B, A+C, ... A+Z, B+C のようにB+A,B+Bを省く．  

↓（参考までに…選ぶのが2個までならほぼ意味ナシ?）↓  
（と言うより，今回は”価格”が制約条件として与えられている & その大きさが20^6と大きいので無理？）  
i 番目以降の品物から，価格の合計が j 以下になるように選んだときの，取りうる価格の総和の最大値を返す関数  
int rec(int i, int j) を考える．  
dp[i][j] => i番目以降の品物から価格の和が j 以下になるように選んだときの最大値を格納していく．  
ﾜﾁｬﾜﾁｬしてくと時間計算量はO(n×m)になり，効率  
